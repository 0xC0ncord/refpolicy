# Copyright (C) 2005 Tresys Technology, LLC

type udev_t; # nscd_client_domain, privmem, privfd, privowner
type udev_exec_t;
type udev_helper_exec_t;
domain_make_daemon_domain(udev_t,udev_exec_t)
domain_make_entrypoint_file(udev_t,udev_helper_exec_t)

type udev_etc_t alias etc_udev_t;
files_make_file(udev_etc_t)

type udev_tbl_t alias udev_tdb_t;
files_make_file(udev_tbl_t)

allow udev_t self:capability { chown dac_override dac_read_search fowner fsetid sys_admin mknod net_raw net_admin };
allow udev_t self:process ~{ ptrace setcurrent setexec setfscreate setrlimit execmem dyntransition };
allow udev_t self:process { execmem setfscreate };
allow udev_t self:fd use;
allow udev_t self:fifo_file { read getattr lock ioctl write append };
allow udev_t self:unix_stream_socket { listen accept };
allow udev_t self:unix_dgram_socket sendto;
allow udev_t self:unix_stream_socket connectto;
allow udev_t self:shm { associate getattr setattr create destroy read write lock unix_read unix_write };
allow udev_t self:sem { associate getattr setattr create destroy read write unix_read unix_write };
allow udev_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
allow udev_t self:msg { send receive };
allow udev_t self:rawip_socket { create ioctl read getattr write setattr append bind connect getopt setopt shutdown };

allow udev_t udev_helper_exec_t:dir { read getattr lock search ioctl };

# read udev config
allow udev_t udev_etc_t:file { read getattr lock ioctl };

# create udev database in /dev/.udevdb
devices_create_dev_entry(udev_t,udev_tbl_t,file)
allow udev_t udev_tbl_t:file { create ioctl read getattr lock write setattr append link unlink rename };

kernel_read_system_state(udev_t)
kernel_get_core_interface_attributes(udev_t)
kernel_use_file_descriptors(udev_t)
kernel_read_device_sysctl(udev_t)
kernel_read_hotplug_sysctl(udev_t)
kernel_read_modprobe_sysctl(udev_t)
kernel_read_kernel_sysctl(udev_t)
kernel_read_hardware_state(udev_t)
kernel_get_selinuxfs_mount_point(udev_t)
kernel_validate_selinux_context(udev_t)
kernel_compute_selinux_av(udev_t)
kernel_compute_create(udev_t)
kernel_compute_relabel(udev_t)
kernel_compute_reachable_user_contexts(udev_t)

files_read_runtime_system_config(udev_t)
files_read_general_system_config(udev_t)

corecommands_execute_general_programs(udev_t)
corecommands_execute_system_programs(udev_t)
corecommands_execute_shell(udev_t)
domain_execute_all_entrypoint_programs(udev_t)

# Security
selinux_read_config(udev_t)
selinux_read_default_contexts(udev_t)
selinux_read_file_contexts(udev_t)

modutils_insmod_transition(udev_t)

logging_send_system_log_message(udev_t)

optional_policy(`consoletype.te', `
consoletype_execute(udev_t)
')

ifdef(`TODO',`
allow udev_t var_log_t:dir search;
allow udev_t var_lock_t:dir search;
allow udev_t var_lock_t:file getattr;
# TODO: Need macro for reading daemon runtime data.
allow udev_t initrc_var_run_t:file r_file_perms;

# Devices
allow udev_t device_t:dir { relabelfrom relabelto create_dir_perms };
file_type_auto_trans(udev_t, device_t, udev_tbl_t, file)

# Mount
allow udev_t mnt_t:dir search;

allow udev_t devpts_t:dir { getattr search };
allow udev_t sysadm_tty_device_t:chr_file { read write };
allow udev_t device_t:sock_file create_file_perms;
allow udev_t device_t:lnk_file create_lnk_perms;
allow udev_t { device_t device_type }:{ chr_file blk_file } { relabelfrom relabelto create_file_perms };

# Dontaudits
dontaudit udev_t initrc_var_run_t:file write;
dontaudit udev_t staff_home_dir_t:dir search;
dontaudit udev_t file_t:dir search;
dontaudit udev_t domain:dir r_dir_perms;
dontaudit udev_t ttyfile:chr_file unlink;

domain_auto_trans(initrc_t, udev_exec_t, udev_t)
domain_auto_trans(kernel_t, udev_exec_t, udev_t)
domain_auto_trans(udev_t, restorecon_exec_t, restorecon_t)
domain_auto_trans(udev_t, ifconfig_exec_t, ifconfig_t)

allow udev_t kernel_t:unix_dgram_socket { sendto ioctl read write };

dbusd_client(system, udev)

# Ifdefs
ifdef(`distro_redhat', `
allow udev_t tmpfs_t:dir rw_dir_perms;
allow udev_t tmpfs_t:sock_file create_file_perms;
allow udev_t tmpfs_t:lnk_file create_lnk_perms;
allow udev_t tmpfs_t:{ chr_file blk_file } { relabelfrom relabelto create_file_perms };
allow udev_t tmpfs_t:dir search;

# for arping used for static IP addresses on PCMCIA ethernet
domain_auto_trans(udev_t, netutils_exec_t, netutils_t)
') dnl end ifdef distro_redhat

ifdef(`hide_broken_symptoms', `
dontaudit restorecon_t udev_t:unix_dgram_socket { read write };
dontaudit ifconfig_t udev_t:unix_dgram_socket { read write };
')

ifdef(`xdm.te', `
allow udev_t xdm_var_run_t:file { getattr read };
')

ifdef(`hotplug.te', `
r_dir_file(udev_t, hotplug_etc_t)
')

ifdef(`pamconsole.te', `
allow udev_t pam_var_console_t:dir search;
allow udev_t pam_var_console_t:file { getattr read };
domain_auto_trans(udev_t, pam_console_exec_t, pam_console_t)
')

ifdef(`dhcpc.te', `
domain_auto_trans(udev_t, dhcpc_exec_t, dhcpc_t)
')
') dnl endif TODO
