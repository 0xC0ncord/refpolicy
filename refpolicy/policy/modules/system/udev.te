# Copyright (C) 2005 Tresys Technology, LLC

policy_module(udev,1.0)

########################################
#
# Declarations
#

type udev_t; # nscd_client_domain
type udev_exec_t;
type udev_helper_exec_t;
kernel_make_object_identity_change_constraint_exception(udev_t)
domain_make_daemon_domain(udev_t,udev_exec_t)
domain_make_entrypoint_file(udev_t,udev_helper_exec_t)
domain_make_file_descriptors_widely_inheritable(udev_t)

type udev_etc_t alias etc_udev_t;
files_make_file(udev_etc_t)

# udev_runtime_t is the type of the udev table file
# cjp: this is probably a copy of udev_tbl_t and can be removed
type udev_runtime_t;
files_make_file(udev_runtime_t)

type udev_tbl_t alias udev_tdb_t;
files_make_file(udev_tbl_t)

type udev_var_run_t;
files_make_daemon_runtime_file(udev_var_run_t)

########################################
#
# Local policy
#

allow udev_t self:capability { chown dac_override dac_read_search fowner fsetid sys_admin mknod net_raw net_admin };
allow udev_t self:process ~{ ptrace setcurrent setexec setfscreate setrlimit execmem dyntransition };
allow udev_t self:process { execmem setfscreate };
allow udev_t self:fd use;
allow udev_t self:fifo_file { read getattr lock ioctl write append };
allow udev_t self:unix_stream_socket { listen accept };
allow udev_t self:unix_dgram_socket sendto;
allow udev_t self:unix_stream_socket connectto;
allow udev_t self:shm { associate getattr setattr create destroy read write lock unix_read unix_write };
allow udev_t self:sem { associate getattr setattr create destroy read write unix_read unix_write };
allow udev_t self:msgq { associate getattr setattr create destroy read write enqueue unix_read unix_write };
allow udev_t self:msg { send receive };
allow udev_t self:rawip_socket { create ioctl read getattr write setattr append bind connect getopt setopt shutdown };

allow udev_t udev_helper_exec_t:dir { read getattr lock search ioctl };

# read udev config
allow udev_t udev_etc_t:file { read getattr lock ioctl };

# create udev database in /dev/.udevdb
allow udev_t udev_tbl_t:file { create ioctl read getattr lock write setattr append link unlink rename };
devices_create_dev_entry(udev_t,udev_tbl_t,file)

allow udev_t udev_var_run_t : dir { read getattr lock search ioctl add_name remove_name write };
allow udev_t udev_var_run_t : file { create ioctl read getattr lock write setattr append link unlink rename };

kernel_read_system_state(udev_t)
kernel_get_core_interface_attributes(udev_t)
kernel_use_file_descriptors(udev_t)
kernel_read_device_sysctl(udev_t)
kernel_read_hotplug_sysctl(udev_t)
kernel_read_modprobe_sysctl(udev_t)
kernel_read_kernel_sysctl(udev_t)
kernel_read_hardware_state(udev_t)
kernel_get_selinuxfs_mount_point(udev_t)
kernel_validate_selinux_context(udev_t)
kernel_compute_selinux_av(udev_t)
kernel_compute_create(udev_t)
kernel_compute_relabel(udev_t)
kernel_compute_reachable_user_contexts(udev_t)
kernel_transition_from(udev_t,udev_exec_t)

devices_manage_device_nodes(udev_t)

filesystem_get_all_filesystems_attributes(udev_t)

init_script_read_runtime_data(udev_t)

files_read_runtime_system_config(udev_t)
files_read_general_system_config(udev_t)

corecommands_execute_general_programs(udev_t)
corecommands_execute_system_programs(udev_t)
corecommands_execute_shell(udev_t)
domain_execute_all_entrypoint_programs(udev_t)

# Security
selinux_read_config(udev_t)
selinux_read_default_contexts(udev_t)
selinux_read_file_contexts(udev_t)
selinux_restorecon_transition(udev_t)

modutils_insmod_transition(udev_t)

logging_send_system_log_message(udev_t)

sysnetwork_ifconfig_transition(udev_t)

optional_policy(`authlogin.te',`
authlogin_pam_console_read_runtime_data(udev_t)
authlogin_pam_console_transition(udev_t)
')

optional_policy(`consoletype.te',`
consoletype_execute(udev_t)
')

optional_policy(`hotplug.te',`
hotplug_read_config(udev_t)
')

optional_policy(`sysnetwork.te',`
sysnetwork_dhcpc_transition(udev_t)
')

ifdef(`TODO',`
allow udev_t var_log_t:dir search;
allow udev_t var_lock_t:dir search;
allow udev_t var_lock_t:file getattr;

allow udev_t mnt_t:dir search;

allow udev_t devpts_t:dir { getattr search };
allow udev_t sysadm_tty_device_t:chr_file { read write };

# Dontaudits
dontaudit udev_t initrc_var_run_t:file write;
dontaudit udev_t staff_home_dir_t:dir search;
dontaudit udev_t file_t:dir search;
dontaudit udev_t domain:dir r_dir_perms;
dontaudit udev_t ttyfile:chr_file unlink;

allow udev_t kernel_t:unix_dgram_socket { sendto ioctl read write };

dbusd_client(system, udev)

# Ifdefs
tunable_policy(`distro_redhat',`
allow udev_t tmpfs_t:dir rw_dir_perms;
allow udev_t tmpfs_t:sock_file create_file_perms;
allow udev_t tmpfs_t:lnk_file create_lnk_perms;
allow udev_t tmpfs_t:{ chr_file blk_file } { relabelfrom relabelto create_file_perms };
allow udev_t tmpfs_t:dir search;

# for arping used for static IP addresses on PCMCIA ethernet
netutils_transition(udev_t)
') dnl end ifdef distro_redhat

tunable_policy(`hide_broken_symptoms',`
dontaudit restorecon_t udev_t:unix_dgram_socket { read write };
dontaudit ifconfig_t udev_t:unix_dgram_socket { read write };
')

optional_policy(`xdm.te',`
allow udev_t xdm_var_run_t:file { getattr read };
')

') dnl endif TODO
